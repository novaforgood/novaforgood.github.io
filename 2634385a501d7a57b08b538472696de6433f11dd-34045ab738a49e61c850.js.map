{"version":3,"file":"2634385a501d7a57b08b538472696de6433f11dd-34045ab738a49e61c850.js","mappings":"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","sources":["webpack://gatsby-starter-hello-world/./node_modules/react-hover-video-player/es/constants.js","webpack://gatsby-starter-hello-world/./node_modules/react-hover-video-player/es/utils.js","webpack://gatsby-starter-hello-world/./node_modules/react-hover-video-player/es/index.js","webpack://gatsby-starter-hello-world/./src/assets/distribution.png","webpack://gatsby-starter-hello-world/./src/assets/distribution.mp4","webpack://gatsby-starter-hello-world/./src/assets/phone.png","webpack://gatsby-starter-hello-world/./src/assets/projectropa.png","webpack://gatsby-starter-hello-world/./src/assets/projectropa.mp4"],"sourcesContent":["var _pausedOverlayWrapper, _videoSizingStyles;\n\n// Enumerates states that the video can be in\nexport var VIDEO_STATE = {\n  paused: 'paused',\n  loading: 'loading',\n  playing: 'playing'\n}; // Enumerates states that the hover player can be in\n\nexport var HOVER_PLAYER_STATE = {\n  paused: 'paused',\n  loading: 'loading',\n  playing: 'playing'\n}; // Enumerates sizing modes which define how the player's contents should be sized relative to each other\n\nexport var SIZING_MODES = {\n  // Everything should be sized based on the paused overlay's dimensions - the video element will expand to fill that space\n  overlay: 'overlay',\n  // Everything should be sized based on the video element's dimensions - the overlays will expand to cover the video\n  video: 'video',\n  // Everything should be sized based on the player's outer container div - the overlays and video will all expand to cover\n  // the container\n  container: 'container',\n  // Manual mode does not apply any special styling and allows the developer to exercise full control\n  // over how everything should be sized - this means you will likely need to provide your own custom styling for\n  // both the paused overlay and the video element\n  manual: 'manual'\n}; // CSS styles to make some contents in the player expand to fill the container\n\nexport var expandToFillContainerStyle = {\n  position: 'absolute',\n  width: '100%',\n  height: '100%',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0\n}; // Styles to apply to the paused overlay wrapper and video element for different sizing modes\n\nexport var pausedOverlayWrapperSizingStyles = (_pausedOverlayWrapper = {}, _pausedOverlayWrapper[SIZING_MODES.overlay] = {\n  position: 'relative'\n}, _pausedOverlayWrapper[SIZING_MODES.video] = expandToFillContainerStyle, _pausedOverlayWrapper[SIZING_MODES.container] = expandToFillContainerStyle, _pausedOverlayWrapper[SIZING_MODES.manual] = null, _pausedOverlayWrapper);\nexport var videoSizingStyles = (_videoSizingStyles = {}, _videoSizingStyles[SIZING_MODES.overlay] = expandToFillContainerStyle, _videoSizingStyles[SIZING_MODES.video] = {\n  display: 'block',\n  width: '100%'\n}, _videoSizingStyles[SIZING_MODES.container] = expandToFillContainerStyle, _videoSizingStyles[SIZING_MODES.manual] = null, _videoSizingStyles);","import { VIDEO_STATE } from './constants';\n/**\n * @function getVideoState\n *\n * Takes a video element and returns its current playing state\n *\n * @param {node} videoElement\n */\n\nexport function getVideoState(videoElement) {\n  if (videoElement.paused || videoElement.ended) {\n    return VIDEO_STATE.paused;\n  } // If the video isn't paused but its readyState indicates it isn't loaded enough\n  // to play yet, it is loading\n\n\n  if (videoElement.readyState < 3) {\n    return VIDEO_STATE.loading;\n  } // If the video isn't paused and its ready state indicates it's loaded enough to play,\n  // assume it's playing\n\n\n  return VIDEO_STATE.playing;\n}\n/**\n * @typedef   {object}  VideoSource\n * @property  {string}  src - The src URL string to use for a video player source\n * @property  {string}  type - The media type of the video, ie 'video/mp4'\n */\n\n/**\n * @function  formatVideoSrc\n *\n * Takes a videoSrc value and formats it as an array of VideoSource objects which can be used to render\n * <source> elements for the video\n *\n * @param {(string|string[]|VideoSource|VideoSource[])}  videoSrc - Source(s) to use for the video player. Accepts 3 different formats:\n *                                                                   - **String**: the URL string to use as the video player's src\n *                                                                   - **Object**: an object with attributes:\n *                                                                     - src: The src URL string to use for a video player source\n *                                                                     - type: The media type of the video source, ie 'video/mp4'\n *                                                                   - **Array**: if you would like to provide multiple sources, you can provide an array of URL strings and/or objects with the shape described above\n *\n * @returns {VideoSource[]} Array of formatted VideoSource objects which can be used to render <source> elements for the video\n */\n\nexport function formatVideoSrc(videoSrc) {\n  var formattedVideoSources = [];\n\n  if (videoSrc == null) {\n    // A videoSrc value is required in order to make the video player work\n    console.error(\"Error: 'videoSrc' prop is required for HoverVideoPlayer component\");\n  } else {\n    // Make sure we can treat the videoSrc value as an array\n    var rawVideoSources = Array.isArray(videoSrc) ? videoSrc : [videoSrc]; // Parse our video source values into an array of VideoSource objects that can be used to render sources for the video\n\n    for (var i = 0, numSources = rawVideoSources.length; i < numSources; i += 1) {\n      var source = rawVideoSources[i];\n\n      if (typeof source === 'string') {\n        // If the source is a string, it's an src URL so format it into a VideoSource object and add it to the array\n        formattedVideoSources.push({\n          src: source\n        });\n      } else if (source && source.src) {\n        // If the source is an object with an src, just add it to the array\n        formattedVideoSources.push({\n          src: source.src,\n          type: source.type\n        });\n      } else {\n        // Log an error if one of the videoSrc values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoSrc':\", source);\n      }\n    }\n  }\n\n  return formattedVideoSources;\n}\n/**\n * @typedef   {object}  VideoCaptionsTrack\n * @property  {string}  src - The src URL string for the captions track file\n * @property  {string}  srcLang - The language code for the language that these captions are in\n * @property  {string}  label - The title of the captions track\n * @property  {boolean} default - Whether this track should be used by default if the user's preferences don't match an available srcLang\n */\n\n/**\n * @function formatVideoCaptions\n *\n * Takes a videoCaptions value and formats it as an array of VideoCaptionsTrack objects which can be used to render\n * <track> elements for the video\n *\n * @param {(string|string[]|VideoCaptionsTrack|VideoCaptionsTrack[])} videoCaptions - Captions track(s) to use for the video player for accessibility. Accepts 3 different formats:\n *                                                                                     - **String**: the URL string to use as the captions track's src\n *                                                                                     - **Object**: an object with attributes:\n *                                                                                       - src: The src URL string for the captions track file\n *                                                                                       - srcLang: The language code for the language that these captions are in (ie, 'en', 'es', 'fr')\n *                                                                                       - label: The title of the captions track\n *                                                                                       - default: Whether this track should be used by default if the user's preferences don't match an available srcLang\n *                                                                                     - **Array**: if you would like to provide multiple caption tracks, you can provide an array of objects with the shape described above\n *\n * @returns {VideoCaptionsTrack[]}  Array of formatted VideoCaptionsTrack objects which can be used to render <track> elements for the video\n */\n\nexport function formatVideoCaptions(videoCaptions) {\n  var formattedVideoCaptions = []; // If captions were provided, format them for use for the video\n\n  if (videoCaptions != null) {\n    // Make sure we can treat the videoCaptions value as an array\n    var rawVideoCaptions = Array.isArray(videoCaptions) ? videoCaptions : [videoCaptions]; // Parse our raw video captions values into an array of formatted VideoCaptionsTrack\n    // objects that can be used to render caption tracks for the video\n\n    for (var i = 0, numCaptions = rawVideoCaptions.length; i < numCaptions; i += 1) {\n      var captions = rawVideoCaptions[i];\n\n      if (captions && captions.src) {\n        formattedVideoCaptions.push({\n          src: captions.src,\n          srcLang: captions.srcLang,\n          label: captions.label,\n          \"default\": Boolean(captions[\"default\"])\n        });\n      } else {\n        // Log an error if one of the videoCaptions values is invalid\n        console.error(\"Error: invalid value provided to HoverVideoPlayer prop 'videoCaptions'\", captions);\n      }\n    }\n  }\n\n  return formattedVideoCaptions;\n}","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport { getVideoState, formatVideoSrc, formatVideoCaptions } from './utils';\nimport { VIDEO_STATE, HOVER_PLAYER_STATE, SIZING_MODES, expandToFillContainerStyle, pausedOverlayWrapperSizingStyles, videoSizingStyles } from './constants';\n/**\n * @component HoverVideoPlayer\n *\n * @param {(string|string[]|VideoSource|VideoSource[])}  videoSrc - Source(s) to use for the video player. Accepts 3 different formats:\n *                                                                   - **String**: the URL string to use as the video player's src\n *                                                                   - **Object**: an object with attributes:\n *                                                                     - src: The src URL string to use for a video player source\n *                                                                     - type: The media type of the video source, ie 'video/mp4'\n *                                                                   - **Array**: if you would like to provide multiple sources, you can provide an array of URL strings and/or objects with the shape described above\n * @param {(VideoCaptionsTrack|VideoCaptionsTrack[])} [videoCaptions] - Captions track(s) to use for the video player for accessibility. Accepts 2 formats:\n *                                                                                      - **Object**: an object with attributes:\n *                                                                                        - src: The src URL string for the captions track file\n *                                                                                        - srcLang: The language code for the language that these captions are in (ie, 'en', 'es', 'fr')\n *                                                                                        - label: The title of the captions track\n *                                                                                        - default: Whether this track should be used by default if the user's preferences don't match an available srcLang\n *                                                                                      - **Array**: if you would like to provide multiple caption tracks, you can provide an array of objects with the shape described above\n * @param {boolean} [focused=false] - Offers a prop interface for forcing the video to start/stop without DOM events\n *                                      When set to true, the video will begin playing and any events that would normally stop it will be ignored\n * @param {boolean} [disableDefaultEventHandling] - Whether the video player's default mouse and touch event handling should be disabled in favor of a fully custom solution using the `focused` prop\n * @param {node}    [hoverTargetRef] - Ref to a custom element that should be used as the target for hover events to start/stop the video\n *                                      By default will just use the container div wrapping the player\n * @param {node}    [pausedOverlay] - Contents to render over the video while it's not playing\n * @param {node}    [loadingOverlay] - Contents to render over the video while it's loading\n * @param {number}  [loadingStateTimeout=200] - Duration in ms to wait after attempting to start the video before showing the loading overlay\n * @param {number}  [overlayTransitionDuration=400] - The transition duration in ms for how long it should take for the overlay to fade in/out\n * @param {boolean} [restartOnPaused=false] - Whether the video should reset to the beginning every time it stops playing after the user mouses out of the player\n * @param {boolean} [unloadVideoOnPaused=false] - Whether we should unload the video's sources when it is not playing in order to free up memory and bandwidth\n *                                                  This can be useful in scenarios where you may have a large number of relatively large video files on a single page;\n *                                                  particularly due to a known bug in Google Chrome, if too many videos are loading in the background at the same time,\n *                                                  it starts to gum up the works so that nothing loads properly and performance can degrade significantly.\n * @param {boolean} [muted=true] - Whether the video player should be muted\n * @param {boolean} [loop=true] - Whether the video player should loop when it reaches the end\n * @param {string}  [preload] - Sets how much information the video element should preload before being played. Accepts one of the following values:\n *                              - **\"none\"**: Nothing should be preloaded before the video is played\n *                              - **\"metadata\"**: Only the video's metadata (ie length, dimensions) should be preloaded\n *                              - **\"auto\"**: The whole video file should be preloaded even if it won't be played\n * @param {string}  [crossOrigin='anonymous'] - Sets how the video element should handle CORS requests. Accepts one of the following values:\n *                                              - **\"anonymous\"**: CORS requests will have the credentials flag set to 'same-origin'\n *                                              - **\"use-credentials\"**: CORS requests for this element will have the credentials flag set to 'include'\n * @param {string}  [className] - Optional className to apply custom styling to the container element\n * @param {object}  [style] - Style object to apply custom inlined styles to the hover player container\n * @param {string}  [pausedOverlayWrapperClassName] - Optional className to apply custom styling to the overlay contents' wrapper\n * @param {object}  [pausedOverlayWrapperStyle] - Style object to apply custom inlined styles to the paused overlay wrapper\n * @param {string}  [loadingOverlayWrapperClassName] - Optional className to apply custom styling to the loading state overlay contents' wrapper\n * @param {object}  [loadingOverlayWrapperStyle] - Style object to apply custom inlined styles to the loading overlay wrapper\n * @param {string}  [videoClassName] - Optional className to apply custom styling to the video element\n * @param {object}  [videoStyle] - Style object to apply custom inlined styles to the video element\n * @param {string}  [sizingMode='video'] - Describes sizing mode to use to determine how the player's contents should be styled. Accepts 4 possible values:\n *                                         - **\"video\"**: Everything should be sized based on the video element's dimensions - the overlays will expand to cover the video\n *                                         - **\"overlay\"**: Everything should be sized based on the paused overlay's dimensions - the video element will expand to fit inside those dimensions\n *                                         - **\"container\"**: Everything should be sized based on the player's outer container div - the overlays and video will all expand to cover the container\n *                                         - **\"manual\"**: Manual mode does not apply any special styling and allows the developer to exercise full control over how everything should be sized - this means you will likely need to provide your own custom styling for both the paused overlay and the video element\n *\n * @license MIT\n */\n\nexport default function HoverVideoPlayer(_ref) {\n  var videoSrc = _ref.videoSrc,\n      _ref$videoCaptions = _ref.videoCaptions,\n      videoCaptions = _ref$videoCaptions === void 0 ? null : _ref$videoCaptions,\n      _ref$focused = _ref.focused,\n      focused = _ref$focused === void 0 ? false : _ref$focused,\n      _ref$disableDefaultEv = _ref.disableDefaultEventHandling,\n      disableDefaultEventHandling = _ref$disableDefaultEv === void 0 ? false : _ref$disableDefaultEv,\n      _ref$hoverTargetRef = _ref.hoverTargetRef,\n      hoverTargetRef = _ref$hoverTargetRef === void 0 ? null : _ref$hoverTargetRef,\n      _ref$pausedOverlay = _ref.pausedOverlay,\n      pausedOverlay = _ref$pausedOverlay === void 0 ? null : _ref$pausedOverlay,\n      _ref$loadingOverlay = _ref.loadingOverlay,\n      loadingOverlay = _ref$loadingOverlay === void 0 ? null : _ref$loadingOverlay,\n      _ref$loadingStateTime = _ref.loadingStateTimeout,\n      loadingStateTimeout = _ref$loadingStateTime === void 0 ? 200 : _ref$loadingStateTime,\n      _ref$overlayTransitio = _ref.overlayTransitionDuration,\n      overlayTransitionDuration = _ref$overlayTransitio === void 0 ? 400 : _ref$overlayTransitio,\n      _ref$restartOnPaused = _ref.restartOnPaused,\n      restartOnPaused = _ref$restartOnPaused === void 0 ? false : _ref$restartOnPaused,\n      _ref$unloadVideoOnPau = _ref.unloadVideoOnPaused,\n      unloadVideoOnPaused = _ref$unloadVideoOnPau === void 0 ? false : _ref$unloadVideoOnPau,\n      _ref$muted = _ref.muted,\n      muted = _ref$muted === void 0 ? true : _ref$muted,\n      _ref$loop = _ref.loop,\n      loop = _ref$loop === void 0 ? true : _ref$loop,\n      _ref$preload = _ref.preload,\n      preload = _ref$preload === void 0 ? null : _ref$preload,\n      _ref$crossOrigin = _ref.crossOrigin,\n      crossOrigin = _ref$crossOrigin === void 0 ? 'anonymous' : _ref$crossOrigin,\n      _ref$className = _ref.className,\n      className = _ref$className === void 0 ? '' : _ref$className,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? null : _ref$style,\n      _ref$pausedOverlayWra = _ref.pausedOverlayWrapperClassName,\n      pausedOverlayWrapperClassName = _ref$pausedOverlayWra === void 0 ? '' : _ref$pausedOverlayWra,\n      _ref$pausedOverlayWra2 = _ref.pausedOverlayWrapperStyle,\n      pausedOverlayWrapperStyle = _ref$pausedOverlayWra2 === void 0 ? null : _ref$pausedOverlayWra2,\n      _ref$loadingOverlayWr = _ref.loadingOverlayWrapperClassName,\n      loadingOverlayWrapperClassName = _ref$loadingOverlayWr === void 0 ? '' : _ref$loadingOverlayWr,\n      _ref$loadingOverlayWr2 = _ref.loadingOverlayWrapperStyle,\n      loadingOverlayWrapperStyle = _ref$loadingOverlayWr2 === void 0 ? null : _ref$loadingOverlayWr2,\n      _ref$videoClassName = _ref.videoClassName,\n      videoClassName = _ref$videoClassName === void 0 ? '' : _ref$videoClassName,\n      _ref$videoStyle = _ref.videoStyle,\n      videoStyle = _ref$videoStyle === void 0 ? null : _ref$videoStyle,\n      _ref$sizingMode = _ref.sizingMode,\n      sizingMode = _ref$sizingMode === void 0 ? SIZING_MODES.video : _ref$sizingMode;\n\n  // Keep track of state to determine how the paused and loading overlays should be displayed\n  var _React$useState = React.useState(HOVER_PLAYER_STATE.paused),\n      overlayState = _React$useState[0],\n      setOverlayState = _React$useState[1]; // Keep track of whether the video is unloaded, meaning its sources should be removed from\n  // the DOM and unloaded for optimization purposes\n  // This is only relevant if `unloadVideoOnPaused` is set to true\n\n\n  var _React$useState2 = React.useState(unloadVideoOnPaused),\n      isVideoUnloaded = _React$useState2[0],\n      setIsVideoUnloaded = _React$useState2[1]; // Keep refs to previous state values for comparison in effect hooks\n\n\n  var previousIsVideoUnloadedRef = React.useRef(isVideoUnloaded);\n  var previousFocusedRef = React.useRef(false); // Keep a ref for all state variables related to the video's state\n  // which need to be managed asynchronously as it attempts to play/pause\n\n  var mutableVideoState = React.useRef(null);\n\n  if (mutableVideoState.current === null) {\n    // Set initial values for our video state\n    mutableVideoState.current = {\n      isPlayAttemptInProgress: false,\n      isPlayAttemptCancelled: false,\n      isPlayerUnmounted: false,\n      // Keep refs for timeouts so we can keep track of and cancel them\n      pauseTimeout: null,\n      loadingStateTimeout: null,\n      // Keep track of the video time that we should start from when the video is played again\n      // This is particularly useful so we can restore our previous place in the video even if\n      // we are unloading it every time it gets paused\n      videoTimeToRestore: 0\n    };\n  } // Element refs\n\n\n  var containerRef = React.useRef(null);\n  var videoRef = React.useRef(null);\n  /**\n   * @function  pauseVideo\n   *\n   * Pauses the video and unloads it if necessary\n   */\n\n  var pauseVideo = React.useCallback(function () {\n    var videoElement = videoRef.current;\n    videoElement.pause();\n\n    if (restartOnPaused) {\n      // If we should restart the video, reset its time to the beginning next time we play\n      videoElement.currentTime = 0;\n    } // Hang onto the time that the video is currently at so we can restore it when we try to play\n    // again even if the video was unloaded\n\n\n    mutableVideoState.current.videoTimeToRestore = videoElement.currentTime;\n\n    if (unloadVideoOnPaused) {\n      // If necessary, unload the video now that it's paused\n      setIsVideoUnloaded(true);\n    }\n  }, [restartOnPaused, unloadVideoOnPaused]);\n  /**\n   * @function playVideo\n   *\n   * Attempts to play the video if it is not already playing\n   */\n\n  var playVideo = React.useCallback(function () {\n    // Clear any timeouts that may have been in progress\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    var videoElement = videoRef.current; // Make sure our play attempt is no longer cancelled since the user is hovering on it again\n\n    mutableVideoState.current.isPlayAttemptCancelled = false; // If the video is already playing, just make sure we keep the overlays hidden\n\n    if (getVideoState(videoElement) === VIDEO_STATE.playing) {\n      setOverlayState(HOVER_PLAYER_STATE.playing);\n      return;\n    }\n\n    if (loadingOverlay) {\n      // If we have a loading overlay, start a timeout to fade it in if it takes too long\n      // for playback to start\n      mutableVideoState.current.loadingStateTimeout = setTimeout(function () {\n        // If the video is still loading when this timeout completes, transition the\n        // player to show a loading state\n        setOverlayState(HOVER_PLAYER_STATE.loading);\n      }, loadingStateTimeout);\n    } // If a play attempt is already in progress, don't start a new one\n\n\n    if (mutableVideoState.current.isPlayAttemptInProgress) return; // We are now attempting to play the video\n\n    mutableVideoState.current.isPlayAttemptInProgress = true; // Ensure we're at the correct video time to start playing from\n\n    videoElement.currentTime = mutableVideoState.current.videoTimeToRestore; // Start playing the video and hang onto the play promise it returns\n\n    var playPromise = videoElement.play();\n\n    if (!playPromise || !playPromise.then) {\n      // If videoElement.play() didn't return a promise, we'll manually create one\n      // ourselves which mimics the same behavior\n      playPromise = new Promise(function (resolve, reject) {\n        // Declaring onVideoPlaybackFailed up here so we can refer to it and remove its event listener\n        // if the video successfully starts playing\n        var _onVideoPlaybackFailed; // Set up event listener to resolve the promise when the video player starts playing\n\n\n        var onVideoPlaybackStarted = function onVideoPlaybackStarted() {\n          // Remove the event listeners we added as cleanup now that the play attempt has succeeded\n          videoElement.removeEventListener('playing', onVideoPlaybackStarted);\n          videoElement.removeEventListener('error', _onVideoPlaybackFailed); // Resolve because we successfully started playing!\n\n          resolve();\n        };\n\n        videoElement.addEventListener('playing', onVideoPlaybackStarted); // Set up event listener to reject the promise when the video player encounters an error\n\n        _onVideoPlaybackFailed = function onVideoPlaybackFailed(event) {\n          // Remove the event listeners we added as cleanup now that the play attempt has failed\n          videoElement.removeEventListener('error', _onVideoPlaybackFailed);\n          videoElement.removeEventListener('playing', onVideoPlaybackStarted); // Reject with the error that was thrown\n\n          reject(event.error);\n        };\n\n        videoElement.addEventListener('error', _onVideoPlaybackFailed);\n      });\n    }\n\n    playPromise.then(function () {\n      // If the player was unmounted before the play promise could resolve, don't do anything\n      if (mutableVideoState.current.isPlayerUnmounted) return;\n\n      if (mutableVideoState.current.isPlayAttemptCancelled) {\n        // If the play attempt was cancelled, immediately pause the video\n        pauseVideo();\n      } else {\n        // If the play attempt wasn't cancelled, hide the overlays to reveal the video now that it's playing\n        setOverlayState(HOVER_PLAYER_STATE.playing);\n      }\n    })[\"catch\"](function (error) {\n      console.error(\"HoverVideoPlayer playback failed for src \" + videoElement.currentSrc + \":\", error);\n\n      if (!mutableVideoState.current.isPlayerUnmounted) {\n        // If the player is still mounted, revert to a paused state\n        pauseVideo();\n      }\n    })[\"finally\"](function () {\n      // The play attempt is now complete\n      mutableVideoState.current.isPlayAttemptInProgress = false;\n      mutableVideoState.current.isPlayAttemptCancelled = false;\n      clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    });\n  }, [loadingOverlay, loadingStateTimeout, pauseVideo]);\n  /**\n   * @function  onHoverStart\n   *\n   * Starts the video when the user mouses hovers on the player\n   */\n\n  var onHoverStart = React.useCallback(function () {\n    if (isVideoUnloaded) {\n      // If the video is currently unloaded, we need to make sure we update our state\n      // to restore the video's sources before we attempt to play it\n      setIsVideoUnloaded(false);\n    } else {\n      playVideo();\n    }\n  }, [isVideoUnloaded, playVideo]);\n  /**\n   * @function  onHoverEnd\n   *\n   * Stops the video and fades the paused overlay in when the user stops hovering on the player\n   */\n\n  var onHoverEnd = React.useCallback(function () {\n    // Clear any timeouts that may have been in progress\n    clearTimeout(mutableVideoState.current.pauseTimeout);\n    clearTimeout(mutableVideoState.current.loadingStateTimeout);\n    var videoElement = videoRef.current; // If the focused override prop is active, ignore any other events attempting to stop the video\n    // Also don't do anything if the video is already paused\n\n    if (focused || getVideoState(videoElement) === VIDEO_STATE.paused) return; // Start fading the paused overlay back in\n\n    setOverlayState(HOVER_PLAYER_STATE.paused);\n\n    if (mutableVideoState.current.isPlayAttemptInProgress) {\n      // If we have a play attempt in progress, mark that the play attempt should be cancelled\n      // so that as soon as the promise resolves, the video should be paused\n      mutableVideoState.current.isPlayAttemptCancelled = true;\n    } else if (pausedOverlay) {\n      // If we have a paused overlay, set a timeout with a duration of the overlay's fade\n      // transition since we want to keep the video playing until the overlay has fully\n      // faded in and hidden it.\n      mutableVideoState.current.pauseTimeout = setTimeout(function () {\n        return pauseVideo();\n      }, overlayTransitionDuration);\n    } else {\n      // If a play attempt isn't in progress and there is no paused overlay, just pause\n      pauseVideo();\n    }\n  }, [focused, overlayTransitionDuration, pauseVideo, pausedOverlay]);\n  /* ~~~~ EFFECTS ~~~~ */\n\n  React.useEffect(function () {\n    // If the focused prop hasn't changed, don't do anything\n    if (previousFocusedRef.current === focused) return; // Use effect to start/stop the video when focused override prop changes\n\n    if (focused) {\n      onHoverStart();\n    } else {\n      onHoverEnd();\n    }\n\n    previousFocusedRef.current = focused;\n  }, [focused, onHoverEnd, onHoverStart]);\n  React.useEffect(function () {\n    // If default event handling is disabled, we shouldn't check for touch events outside of the player\n    if (disableDefaultEventHandling) return undefined;\n    var hoverTargetElement = // If a ref to a custom hover target was provided, we'll use that as our target element\n    hoverTargetRef ? hoverTargetRef.current : // If no custom target was provided, default to the player's container div\n    containerRef.current; // Add all relevant event listeners to the target element to make\n    // it start and stop correctly\n\n    hoverTargetElement.addEventListener('mouseenter', onHoverStart);\n    hoverTargetElement.addEventListener('mouseleave', onHoverEnd);\n    hoverTargetElement.addEventListener('focus', onHoverStart);\n    hoverTargetElement.addEventListener('blur', onHoverEnd);\n    hoverTargetElement.addEventListener('touchstart', onHoverStart); // Event listener pauses the video when the user touches somewhere outside of the player\n\n    function onWindowTouchStart(event) {\n      if (!hoverTargetElement.contains(event.target)) {\n        onHoverEnd();\n      }\n    }\n\n    window.addEventListener('touchstart', onWindowTouchStart); // Remove all event listeners on cleanup\n\n    return function () {\n      hoverTargetElement.removeEventListener('mouseenter', onHoverStart);\n      hoverTargetElement.removeEventListener('mouseleave', onHoverEnd);\n      hoverTargetElement.removeEventListener('focus', onHoverStart);\n      hoverTargetElement.removeEventListener('blur', onHoverEnd);\n      hoverTargetElement.removeEventListener('touchstart', onHoverStart);\n      window.removeEventListener('touchstart', onWindowTouchStart);\n    };\n  }, [disableDefaultEventHandling, hoverTargetRef, onHoverEnd, onHoverStart]);\n  React.useEffect(function () {\n    // Manually setting the `muted` attribute on the video element via an effect in order\n    // to avoid a know React issue with the `muted` prop not applying correctly on initial render\n    // https://github.com/facebook/react/issues/10389\n    videoRef.current.muted = muted;\n  }, [muted]);\n  React.useEffect(function () {\n    // Don't do anything if the video's unloaded state hasn't changed\n    if (previousIsVideoUnloadedRef.current === isVideoUnloaded) return; // Since the video's sources have changed, perform a manual load to update\n    // or unload the video's current source\n\n    videoRef.current.load();\n\n    if (!isVideoUnloaded) {\n      // If the video was just changed from being unloaded, that means we're trying to play,\n      // so let's kick off a play attempt now that the video's sources are restored\n      playVideo();\n    }\n\n    previousIsVideoUnloadedRef.current = isVideoUnloaded;\n  }, [isVideoUnloaded, onHoverStart, playVideo]);\n  React.useEffect(function () {\n    var videoElement = videoRef.current; // Ensure casting and PiP controls aren't shown on the video\n\n    videoElement.disableRemotePlayback = true;\n    videoElement.disablePictureInPicture = true;\n    return function () {\n      // Clear any outstanding timeouts when the component unmounts to prevent memory leaks\n      clearTimeout(mutableVideoState.current.pauseTimeout);\n      clearTimeout(mutableVideoState.current.loadingStateTimeout); // Mark that the player is unmounted so that we won't try to update the component state\n      // if the play promise resolves afterward\n\n      mutableVideoState.current.isPlayerUnmounted = true;\n    };\n  }, []);\n  /* ~~~~ END EFFECTS ~~~~ */\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    \"data-testid\": \"hover-video-player-container\",\n    ref: containerRef,\n    className: className,\n    style: _extends({\n      position: 'relative'\n    }, style)\n  }, pausedOverlay && /*#__PURE__*/React.createElement(\"div\", {\n    style: _extends({}, pausedOverlayWrapperSizingStyles[sizingMode], {\n      zIndex: 1,\n      opacity: overlayState !== HOVER_PLAYER_STATE.playing ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\"\n    }, pausedOverlayWrapperStyle),\n    className: pausedOverlayWrapperClassName,\n    \"data-testid\": \"paused-overlay-wrapper\"\n  }, pausedOverlay), loadingOverlay && /*#__PURE__*/React.createElement(\"div\", {\n    style: _extends({}, expandToFillContainerStyle, {\n      zIndex: 2,\n      opacity: overlayState === HOVER_PLAYER_STATE.loading ? 1 : 0,\n      transition: \"opacity \" + overlayTransitionDuration + \"ms\"\n    }, loadingOverlayWrapperStyle),\n    className: loadingOverlayWrapperClassName,\n    \"data-testid\": \"loading-overlay-wrapper\"\n  }, loadingOverlay), /*#__PURE__*/React.createElement(\"video\", {\n    loop: loop,\n    playsInline: true,\n    preload: preload,\n    crossOrigin: crossOrigin,\n    ref: videoRef,\n    style: _extends({}, videoSizingStyles[sizingMode], {\n      objectFit: 'cover'\n    }, videoStyle),\n    className: videoClassName,\n    \"data-testid\": \"video-element\"\n  }, !isVideoUnloaded && // If the video is not unloaded, parse the `videoSrc` prop into an array of objects and render them\n  // as sources for the video\n  formatVideoSrc(videoSrc).map(function (_ref2) {\n    var src = _ref2.src,\n        type = _ref2.type;\n    return /*#__PURE__*/React.createElement(\"source\", {\n      key: src,\n      src: src,\n      type: type\n    });\n  }), formatVideoCaptions(videoCaptions).map(function (_ref3) {\n    var src = _ref3.src,\n        srcLang = _ref3.srcLang,\n        label = _ref3.label,\n        isDefault = _ref3[\"default\"];\n    return /*#__PURE__*/React.createElement(\"track\", {\n      key: src,\n      kind: \"captions\",\n      src: src,\n      srcLang: srcLang,\n      label: label,\n      \"default\": isDefault\n    });\n  })));\n}","export default __webpack_public_path__ + \"static/distribution-79a2de51020f5a43b5b4a9e7240b62e3.png\";","export default __webpack_public_path__ + \"static/distribution-055557000179368a9dca27001853d812.mp4\";","export default __webpack_public_path__ + \"static/phone-e3386ea424aa92dbb54e3a3173a5f7f8.png\";","export default __webpack_public_path__ + \"static/projectropa-0c8861c356283f6c56ef5932da817cb9.png\";","export default __webpack_public_path__ + \"static/projectropa-7bc420da40ea9557e4daae661ba401ff.mp4\";"],"names":["_pausedOverlayWrapper","_videoSizingStyles","VIDEO_STATE","paused","loading","playing","HOVER_PLAYER_STATE","SIZING_MODES","overlay","video","container","manual","expandToFillContainerStyle","position","width","height","top","bottom","left","right","pausedOverlayWrapperSizingStyles","videoSizingStyles","display","getVideoState","videoElement","ended","readyState","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","HoverVideoPlayer","_ref","videoSrc","_ref$videoCaptions","videoCaptions","_ref$focused","focused","_ref$disableDefaultEv","disableDefaultEventHandling","_ref$hoverTargetRef","hoverTargetRef","_ref$pausedOverlay","pausedOverlay","_ref$loadingOverlay","loadingOverlay","_ref$loadingStateTime","loadingStateTimeout","_ref$overlayTransitio","overlayTransitionDuration","_ref$restartOnPaused","restartOnPaused","_ref$unloadVideoOnPau","unloadVideoOnPaused","_ref$muted","muted","_ref$loop","loop","_ref$preload","preload","_ref$crossOrigin","crossOrigin","_ref$className","className","_ref$style","style","_ref$pausedOverlayWra","pausedOverlayWrapperClassName","_ref$pausedOverlayWra2","pausedOverlayWrapperStyle","_ref$loadingOverlayWr","loadingOverlayWrapperClassName","_ref$loadingOverlayWr2","loadingOverlayWrapperStyle","_ref$videoClassName","videoClassName","_ref$videoStyle","videoStyle","_ref$sizingMode","sizingMode","_React$useState","overlayState","setOverlayState","_React$useState2","isVideoUnloaded","setIsVideoUnloaded","previousIsVideoUnloadedRef","previousFocusedRef","mutableVideoState","current","isPlayAttemptInProgress","isPlayAttemptCancelled","isPlayerUnmounted","pauseTimeout","videoTimeToRestore","containerRef","videoRef","pauseVideo","pause","currentTime","playVideo","clearTimeout","setTimeout","playPromise","play","then","Promise","resolve","reject","_onVideoPlaybackFailed","onVideoPlaybackStarted","removeEventListener","addEventListener","event","error","console","currentSrc","onHoverStart","onHoverEnd","hoverTargetElement","window","onWindowTouchStart","contains","load","disableRemotePlayback","disablePictureInPicture","ref","zIndex","opacity","transition","playsInline","objectFit","formattedVideoSources","rawVideoSources","Array","isArray","numSources","push","src","type","formatVideoSrc","map","_ref2","formattedVideoCaptions","rawVideoCaptions","numCaptions","captions","srcLang","label","Boolean","formatVideoCaptions","_ref3","isDefault","kind"],"sourceRoot":""}